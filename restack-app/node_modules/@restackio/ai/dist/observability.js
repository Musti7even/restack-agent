"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
const worker_1 = require("@temporalio/worker");
const node_util_1 = require("node:util");
const supportsColor = __importStar(require("supports-color"));
const stderrHasColors = !!supportsColor.stderr;
const format = node_util_1.formatWithOptions.bind(undefined, { colors: stderrHasColors });
const blackListMeta = ['sdkComponent', 'isLocal', 'attempt', 'namespace', 'taskToken', 'activityId'];
const renameCompleteActivityOrWorkflowMessage = (message) => {
    const lowerCaseMessage = message.toLowerCase();
    if (lowerCaseMessage.includes('activity')) {
        return lowerCaseMessage.replace('activity', 'function');
    }
    return message;
};
const extractUsefulMeta = (meta) => {
    if (!meta) {
        return {};
    }
    const usefulMeta = {};
    // Include all keys that aren't in blackListMeta
    Object.entries(meta).forEach(([key, value]) => {
        if (!blackListMeta.includes(key)) {
            usefulMeta[key] = value;
        }
    });
    // Special case: rename activityType to function
    if ('activityType' in meta) {
        usefulMeta.function = meta.activityType;
        delete usefulMeta.activityType;
    }
    return usefulMeta;
};
function customLogFunction(entry) {
    const { level, timestampNanos, message, meta } = entry;
    const date = new Date(Number(BigInt(timestampNanos) / BigInt(1000000)));
    if (!meta)
        return;
    if (level === 'DEBUG' && !meta.clientLog && !meta.restack) {
        writeToStderr({
            date,
            level,
            message: renameCompleteActivityOrWorkflowMessage(message),
            meta: extractUsefulMeta(meta)
        });
    }
    // Handle error messages
    if (meta.error) {
        const err = new Error(meta.error);
        if (err.message.toLowerCase().includes('activity'))
            return;
        writeToStderr({
            date,
            level: 'ERROR',
            message: err.message,
            meta: extractUsefulMeta(meta)
        });
        return;
    }
    // Handle restack messages
    if (meta.restack === true || meta.clientLog === true) {
        const { restack, clientLog } = meta, rest = __rest(meta, ["restack", "clientLog"]);
        const usefulMeta = extractUsefulMeta(rest);
        writeToStderr({
            date,
            level,
            message,
            meta: usefulMeta,
            onlyIncludeMetaIfNotEmpty: true
        });
        return;
    }
}
function writeToStderr({ date, level, message, meta, onlyIncludeMetaIfNotEmpty = false }) {
    const metaStr = onlyIncludeMetaIfNotEmpty && Object.keys(meta).length === 0
        ? ''
        : ` ${format(meta)}`;
    process.stderr.write(`[restack]${format(date)} [${level}] ${message}${metaStr}\n`);
}
const logger = new worker_1.DefaultLogger("DEBUG", customLogFunction);
exports.logger = logger;
if (!worker_1.Runtime._instance) {
    worker_1.Runtime.install({
        logger,
        telemetryOptions: {
            logging: {
                filter: (0, worker_1.makeTelemetryFilterString)({ core: "INFO", other: "INFO" }),
                forward: {},
            },
        },
    });
}
